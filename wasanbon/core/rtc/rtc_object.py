import sys, os, subprocess
import wasanbon
from wasanbon.util import git
#from wasanbon.util import github_ref
from wasanbon.core.rtc import rtcprofile
from wasanbon.core.rtc import packageprofile
from wasanbon.core.rtc import build
from wasanbon.core.package import run

from wasanbon.core.repositories import github_api

import repository


class RtcObject():

    def __init__(self, path, verbose=False, ns_addr='localhost:2809'):
        self._path = path
        self.ns_addr = ns_addr
        self._rtc_xml = ""
        self._rtcprofile = None
        if os.path.isdir(os.path.join(path, '.git')):
            self._protocol = 'git'
        else:
            self._protocol = 'hg'

        for root, dirs, files in os.walk(path):
            if 'RTC.xml' in files:
                self._rtc_xml = os.path.join(root, 'RTC.xml')
                return
        raise wasanbon.RTCProfileNotFoundException()
        pass

    @property
    def rtcprofile(self):
        if not self._rtcprofile:
            self._rtcprofile = rtcprofile.RTCProfile(self._rtc_xml)
        return self._rtcprofile

    @property
    def description(self):
        return self.rtcprofile.basicInfo.description

    @property
    def packageprofile(self):
        return packageprofile.PackageProfile(self.rtcprofile)

    @property
    def path(self):
        return self._path

    @property
    def name(self):
        return self.rtcprofile.basicInfo.name
    
    @property
    def language(self):
        return self.rtcprofile.language.kind

    def build(self, verbose=False):
        if self.language == 'C++':
            return build.build_rtc_cpp(self.rtcprofile, verbose=verbose)
        elif self.language == 'Python':
            return build.build_rtc_python(self.rtcprofile, verbose=verbose)
        elif self.language == 'Java':
            return build.build_rtc_java(self.rtcprofile, verbose=verbose)
        pass
    
    @property
    def repository(self):
        git_obj = wasanbon.util.git.GitRepository(self.path)
        return repository.RtcRepository(self.name, url=git_obj.url, desc="", hash=git_obj.hash)


    def clean(self, verbose=False):
        if self.language == 'C++':
            build.clean_rtc_cpp(self.rtcprofile, verbose=verbose)
        elif self.language == 'Java':
            build.clean_rtc_java(self.rtcprofile, verbose=verbose)
        pass

    def is_git_repo(self, verbose=False):
        try:
            git_obj = wasanbon.util.git.GitRepository(self.path, init=True, verbose=verbose)        
        except wasanbon.RepositoryNotFoundException, ex:
            return False
        return True

    def git_init(self, verbose=False):
        git_obj = wasanbon.util.git.GitRepository(self.path, init=True, verbose=verbose,
                                                  ignore=['build-*', '*.log', '*.bak'])
        git_obj.add(['.'], verbose=verbose)
        git_obj.add(['.project', '.gitignore'], verbose=verbose)
        first_comment = 'This if first commit. This repository is generated by wasanbon'    
        git_obj.commit(first_comment, verbose=verbose)
        return self.git

    def github_init(self, user, passwd, verbose=False):
        github_obj = github_api.GithubReference(user, passwd)
        repo = github_obj.create_repo(self.name)
        git.git_command(['remote', 'add', 'origin', 'https://github.com/' + user + '/' + self.name + '.git'], verbose=verbose, path=self.path)
        git.git_command(['push', '-u', 'origin', 'master'], verbose=verbose, path=self.path)    
        return self

    def github_pullrequest(self, user, passwd, title, body, verbose=False):
        github_obj = github_api.GithubReference(user, passwd)
        github_obj.pullrequest(self.repository.url, title, body, verbose=verbose)
        return self

    def git_branch(self, verbose=False):
        #git symbolic-ref --short HEAD
        p = git.git_command(['symbolic-ref', '--short', 'HEAD'], verbose=False, path=self.path, pipe=True)
        p.wait()
        return p.stdout.readline().strip()

    @property
    def git(self):
        return git.GitRepository(self.path)

    @property
    def hg(self):
        return None

    def commit(self, comment, verbose=False):
        self.git.commit(comment, verbose=verbose)
        return self

    def checkout(self, verbose=False, hash=''):
        self.git.checkout(verbose=verbose, hash=hash)
        return self

    def pull(self, verbose=False):
        self.git.pull(verbose=verbose)
        return self

    def push(self, verbose=False):
        self.git.push(verbose=verbose)
        return self

    def status(self, verbose=True):
        self.git.status(verbose=verbose)

    def get_full_path_in_ns(self):
        return '/' + self.ns_addr + '/' + self.name + '0' + '.rtc'

    def replace_code(self, parser, dic, port_type):
        print parser.init_code
        code = code_template[port_type]['TimedType']['init']
        for key, value in dic.items():
            code = code.replace(key, value)
        parser.init_code = parser.init_code +  code

        code = code_template[port_type]['TimedType']['on_initialize']
        for key, value in dic.items():
            code = code.replace(key, value)
        parser.on_initialize = parser.on_initialize + code

    def add_port_to_py(self, type_name, port_name, port_type):
        filepath = self.packageprofile.getSourceFiles()[0]
        p = PythonCodeParser(filepath)
        
        dic = {'$Initializer': "0",
               '$PortName': port_name,
               '$TimedType': type_name}
        matched = False
        for key, value in initializer_list.items():
            if type_name in type_list[key]:
                dic['$Initializer'] = value
                matched = True

        self.replace_code(p, dic, port_type)

        p.save()
        
    def add_in_port(self, type_name, port_name):
        if self.language == 'Python':
            self.add_port_to_py(type_name, port_name, 'InPort')
        else:
            raise wasanbon.UnsupportedLanguageException()

    def add_out_port(self, type_name, port_name):
        if self.language == 'Python':
            self.add_port_to_py(type_name, port_name, 'OutPort')
        else:
            raise wasanbon.UnsupportedLanguageException()


def available_type_list():
    l = type_list['TimedType'] + type_list['TimedSeqType']
    return l

type_list = {
    'TimedType' : ['RTC.TimedOctet', 'RTC.TimedBoolean', 'RTC.TimedChar', 'RTC.TimedShort', 'RTC.TimedLong', 'RTC.TimedDouble', 'RTC.TimedFloat', 'RTC.TimedChar'],
    'TimedStr' : ['RTC.TimedString'],
    'TimedPoint2D' : ['RTC.TimedPoint2D'],
    'TimedVelocity2D' : ['RTC.TimedVelocity2D'],
    'TimedPose2D' : ['RTC.TimedPose2D'],
    }    

type_list['TimedSeqType'] = [t + 'Seq' for t in type_list['TimedType']] + [t + 'Seq' for t in type_list['TimedStr']]


initializer_list = {
    'TimedType' : 'RTC.Time(0, 0), 0',
    'TimedStr'  : 'RTC.Time(0, 0), ""',
    'TimedSeqType' : 'RTC.Time(0, 0), []',
    'TimedPoint2D' : 'RTC.Time(0, 0), 0, 0', 
    'TimedVelocity2D' : 'RTC.Time(0, 0), RTC.Velocity2D(0, 0, 0)',
    'TimedPose2D' : 'RTC.Time(0, 0), RTC.Pose2D(RTC.Point2D(0, 0), 0)',
    }

code_template = {
    'InPort' : {
        'TimedType' : {
            'init' :  """
                self._d_$PortName = $TimedType($Initializer)
                \"""
                \"""
                self._$PortNameIn = OpenRTM_aist.InPort("$PortName", self._d_$PortName)
""",
            'on_initialize' : """
                self.addInPort("$PortName", self._$PortNameIn)
"""
            }
        },
    'OutPort' : {
        'TimedType' : {
            'init' :  """
                self._d_$PortName = $TimedType($Initializer)
                \"""
                \"""
                self._$PortNameOut = OpenRTM_aist.OutPort("$PortName", self._d_$PortName)
""",
            'on_initialize' : """
                self.addOutPort("$PortName", self._$PortNameOut)
"""
            }
        }
    }

class PythonCodeParser:
    __init_code_starter = '{%wsb:init'
    __on_init_code_starter = '{%wsb:on_initialize'
    __tag_ender = '%}'

    def __init__(self, fullpath):
        self.fullpath = fullpath
        self.init_code = self.get_init_code()
        self.on_initialize = self.get_on_initialize()

    def get_init_code(self):
        file = open(self.fullpath, 'r')
        def return_init_code():
            retval = ''
            for line in file:
                if line.find(self.__tag_ender) > 0:
                    return retval
                retval = retval + line
            return None
        for line in file:
            if line.find(self.__init_code_starter) > 0:
                return return_init_code()
        return None

    def get_on_initialize(self):
        file = open(self.fullpath, 'r')
        def return_init_code():
            retval = ''
            for line in file:
                if line.find(self.__tag_ender) > 0:
                    return retval
                retval = retval + line
            return None

        for line in file:
            if line.find(self.__on_init_code_starter) > 0:
                return return_init_code()
        return None

    
    def save(self):
        import datetime
        n = datetime.datetime.now()
        ts = "%4d%02d%02d%02d%02d%02d" %  (n.year, n.month, n.day, n.hour, n.minute, n.second)
        os.rename(self.fullpath, self.fullpath + ts)
        fin = open(self.fullpath + ts, 'r')
        fout = open(self.fullpath, 'w')

        mode = None
        for line in fin:

            if line.find(self.__init_code_starter) > 0:
                mode = 'init'
                fout.write(line)
                fout.write(self.init_code)
                pass
            if line.find(self.__on_init_code_starter) > 0:
                mode = 'on_initialize'
                fout.write(line)
                fout.write(self.on_initialize)
                pass

            elif line.find(self.__tag_ender) > 0:
                mode = None
                pass

            if mode == None:
                fout.write(line)

        fout.close()
        fin.close()
